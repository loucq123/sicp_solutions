#lang racket
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))
(define (leaf? object)
  (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))
(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit -- CHOOSE-BRANCH" bit))))
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)     ;symbol
                               (cadr pair))   ;frequency
                    (make-leaf-set (cdr pairs))))))
(define sample-tree
  (make-code-tree (make-leaf 'A 3)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))
(define (char-in-symbols? char symbols)
  (cond ((null? symbols) false)
        ((eq? char (car symbols)) true)
        (else
         (char-in-symbols? char (cdr symbols)))))
(define (encode-symbol char tree)
  (cond ((and (leaf? tree) (eq? char (symbol-leaf tree)))
         '())
        ((char-in-symbols? char (symbols (left-branch tree)))
         (cons 0 (encode-symbol char (left-branch tree))))
        ((char-in-symbols? char (symbols (right-branch tree)))
         (cons 1 (encode-symbol char (right-branch tree))))
        (else (error "bad char -- CHOOSE_BRANCH" char))))
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
(define (successive-merge leaves)
  (cond ((null? leaves) '())
        ((null? (cdr leaves)) (car leaves))
        (else
         (successive-merge (adjoin-set (make-code-tree (car leaves) (cadr leaves))
                                       (cddr leaves))))))
(define pairs '((a 2) (na 16) (boom 1) (Sha 3) (Get 2) (yip 9) (job 2) (Wah 1)))
(define tree (generate-huffman-tree pairs))
(define message '(Get a job
                       Sha na na na na na na na na
                       Get a job
                       Sha na na na na na na na na
                       Wah yip yip yip yip yip yip yip yip yip
                       Sha boom))
(count(encode message tree))
(define (count sequence)
  (if (null? sequence)
      0
      (+ 1 (count (cdr sequence)))))
      